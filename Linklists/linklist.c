#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * Définir la structure du maillon
 */
struct maillon{
    char *mot; // Pointeur vers la chaîne de caractères représentant le mot
    struct maillon *suiv; // Pointeur vers le maillon suivant dans la liste
};

typedef struct maillon MAILLON, *PTR;

/**
 * ajoute_debut - Ajoute un nouveau maillon contenant le mot au début de la liste
 * @mot: le mot à ajouter
 * @L: la liste chaînée
 *
 * Retourne : le pointeur vers la nouvelle liste
 */
PTR ajoute_debut(char *mot, PTR L){
    PTR new_maillon = (PTR)malloc(sizeof(MAILLON));
    if (new_maillon == NULL) {
        fprintf(stderr, "Erreur : espace non allouée ");
        exit(EXIT_FAILURE);
    }
    new_maillon->mot = mot;
    new_maillon->suiv = L;
    return new_maillon;
}

/**
 * ajoute_fin - Ajoute un nouveau maillon contenant le mot à la fin de la liste
 * @mot: le mot à ajouter
 * @L: la liste chaînée
 *
 * Retourne : le pointeur vers la nouvelle liste
 */
PTR ajoute_fin(char *mot, PTR L){
    PTR new_maillon = (PTR)malloc(sizeof(MAILLON));
    if (new_maillon == NULL){
            fprintf(stderr, "Erreur : espace non allouée ");
            exit(EXIT_FAILURE);
        }
    new_maillon->mot = mot;
    new_maillon->suiv = NULL;
    if (L == NULL){
        L = new_maillon;
        return L; 
    }
    PTR last_maillon = L;
    while (last_maillon->suiv != NULL){
        last_maillon = last_maillon->suiv;
    }
    last_maillon->suiv = new_maillon;
    return L;
}

/**
 * supprimer - Supprime le maillon contenant le mot spécifié de la liste
 * @mot: le mot à supprimer
 * @L: la liste chaînée
 *
 * Retourne : le pointeur vers la nouvelle liste
 */
PTR supprimer(char *mot, PTR L){
    PTR prec = NULL;
    PTR courant = L;
    while (courant != NULL){
        if (*(courant->mot) == *mot){
            if (prec == NULL){
                L = courant->suiv;
            } else {
                prec->suiv = courant->suiv;
            }
            free(courant);
        }
        prec = courant;
        courant = courant->suiv;
    }
    return L;
}

/**
 * premiers - Affiche les premiers n mots de la liste
 * @liste: la liste chaînée
 * @n: nombre de mots à afficher
 */
void premiers(PTR liste, int n) {
    PTR copie = liste;
    printf("Nous allons afficher les %d premiers elements\n", n);
    for (int i = 0; i < n && copie != NULL ; i++){
        printf("%c\n", *(copie->mot)); 
        copie = copie->suiv;
    }
}

/**
 * purifie - Supprime les doublons consécutifs dans la liste
 * @liste: la liste chaînée
 */
void purifie(MAILLON *liste){
    MAILLON *courant = liste;
    while (courant != NULL && courant->suiv != NULL){
        MAILLON *suivant = courant->suiv;
        if (*(courant->mot) == *suivant->mot){
            courant->suiv = suivant->suiv;
            free(suivant);
        } else {
            courant = courant->suiv;
        }
    }  
}

int main() {
    PTR liste = NULL;
    char mot1 = 'a';
    char mot2 = 'b';
    char mot3 = 'c';
    char mot4 = 'e';
    char mot5 = 'e';
    char mot6 = 'g';
    char mot7 = 'g';
    liste = ajoute_debut(&mot1, liste);
    liste = ajoute_fin(&mot2, liste);
    liste = ajoute_fin(&mot3, liste);
    liste = ajoute_fin(&mot4, liste);
    liste = ajoute_fin(&mot5, liste);
    liste = ajoute_fin(&mot6, liste);
    liste = ajoute_fin(&mot7, liste);
    premiers(liste, 10);
    purifie(liste);
    printf("Liste après purification :\n");
    premiers(liste, 10);
    liste = supprimer(&mot7, liste);
    printf("Liste après suppression de 'g' :\n");
    premiers(liste, 10);
    return 0;
}
